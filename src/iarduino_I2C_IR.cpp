#include "iarduino_I2C_IR.h"																									//
																																//
//		Инициализация модуля:																									//	Возвращаемое значение: результат инициализации.
bool	iarduino_I2C_IR::begin				(void){																				//	Параметр: отсутствует
		//	Инициируем работу с шиной I2C:																						//
			objI2C->begin(100);																									//	Инициируем передачу данных по шине I2C на скорости 100 кГц.
		//	Если адрес не указан, то ищим модуль на шине I2C:																	//
			if(valAddrTemp==0){																									//
				for(int i=1; i<127; i++){																						//	Проходим по всем адресам на шине I2C
					if( objI2C->checkAddress(i)											){	valAddr=i; delay(2);				//	Если на шине I2C есть устройство с адресом i, то используем этот адрес для проверки найденного модуля...
					if(_readBytes(REG_MODEL,4)											){										//	Читаем 4 байта начиная с регистра «REG_MODEL» в массив «data».
					if( data[0]     == DEF_MODEL_IR0     || data[0] == DEF_MODEL_IR1	){										//	Если у модуля с адресом i в регистре «MODEL»   (data[0]) хранится значение DEF_MODEL_IR0 или DEF_MODEL_IR1, то ...
					if((data[2]>>1) == i                 || data[2] == 0xFF				){										//	Если у модуля с адресом i в регистре «ADDRESS» (data[2]) хранится значение i (адрес+младший бит) или 0xFF (адрес не задавался), то ...
					if( data[3]     == DEF_CHIP_ID_FLASH || data[3] == DEF_CHIP_ID_METRO){										//	Если у модуля с адресом i в регистре «CHIP_ID» (data[3]) хранится значение DEF_CHIP_ID_FLASH (идентификатор модулей Flash), или DEF_CHIP_ID_METRO (идентификатор модулей Metro), то ...
						valAddrTemp=i; i=128;																					//	Считаем что модуль обнаружен, сохраняем значение i как найденный адрес и выходим из цикла.
					}}}}}																										//
				}																												//
			}																													//
		//	Если модуль не найден, то возвращаем ошибку инициализации:															//
			if( valAddrTemp == 0														){	valAddr=0; return false;}			//
		//	Проверяем наличие модуля на шине I2C:																				//
			if( objI2C->checkAddress(valAddrTemp) == false								){	valAddr=0; return false;}			//	Если на шине I2C нет устройств с адресом valAddrTemp, то возвращаем ошибку инициализации
			valAddr=valAddrTemp;																								//	Сохраняем адрес модуля на шине I2C.
		//	Проверяем значения регистров модуля:																				//
			if(_readBytes(REG_MODEL,4)==false											){	valAddr=0; return false;}			//	Если не удалось прочитать 4 байта в массив «data» из модуля начиная с регистра «REG_MODEL», то возвращаем ошибку инициализации.
			if( data[0]     != DEF_MODEL_IR0     && data[0] != DEF_MODEL_IR1			){	valAddr=0; return false;}			//	Если значение  регистра «MODEL»   (data[0]) не совпадает со значением DEF_MODEL_IR0 и не совпадает со значением DEF_MODEL_IR1, то возвращаем ошибку инициализации.
			if((data[2]>>1) != valAddrTemp       && data[2] !=0xFF						){	valAddr=0; return false;}			//	Если значение  регистра «ADDRESS» (data[2]) не совпадает с адресом модуля и не совпадает со значением 0xFF, то возвращаем ошибку инициализации.
			if( data[3]     != DEF_CHIP_ID_FLASH && data[3] != DEF_CHIP_ID_METRO		){	valAddr=0; return false;}			//	Если значение  регистра «CHIP_ID» (data[3]) не совпадает со значением DEF_CHIP_ID_FLASH и DEF_CHIP_ID_METRO, то возвращаем ошибку инициализации.
			valVers=data[1];																									//	Сохраняем байт регистра «VERSION» (data[1]) в переменую «valVers».
		//	Перезагружаем модуль устанавливая его регистры в значение по умолчанию:												//
			reset();																											//	Выполняем программную перезагрузку.
			delay(100);																											//
			return true;																										//	Возвращаем флаг успешной инициализаии.
}																																//
																																//
//		Перезагрузка модуля:																									//	Возвращаемое значение:	результат перезагрузки.
bool	iarduino_I2C_IR::reset				(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Устанавливаем бит перезагрузки:																					//
				if(_readBytes(REG_BITS_0,1)==false){return false;}																//	Читаем 1 байт регистра «BITS_0» в массив «data».
				data[0] |= 0b10000000;																							//	Устанавливаем бит «SET_RESET»
				if(_writeBytes(REG_BITS_0,1)==false){return false;}																//	Записываем 1 байт в регистр «BITS_0» из массива «data».
			//	Ждём установки флага завершения перезагрузки:																	//
				do{ if(_readBytes(REG_FLAGS_0,1)==false){return false;} }														//	Читаем 1 байт регистра «REG_FLAGS_0» в массив «data».
				while( (data[0]&0b10000000) == 0);																				//	Повторяем чтение пока не установится флаг «FLG_RESET».
				return true;																									//
			}else{																												//	Иначе, если модуль не инициализирован, то ...
				return false;																									//	Возвращаем ошибку
			}																													//
}																																//
																																//
//		Смена адреса модуля:																									//	Возвращаемое значение:	резульат смены адреса.
bool	iarduino_I2C_IR::changeAddress		(uint8_t newAddr){																	//	Параметр:				newAddr - новый адрес модуля (0x07 < адрес < 0x7F).
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Проверяем новый адрес:																							//
				if(newAddr>0x7F){newAddr>>=1;}																					//	Корректируем адрес, если он указан с учётом бита RW.
				if(newAddr==0x00 || newAddr==0x7F){return false;}																//	Запрещаем устанавливать адрес 0x00 и 0x7F.
			//	Записываем новый адрес:																							//
				if(_readBytes(REG_BITS_0,1)==false){return false;}																//	Читаем 1 байт регистра «BITS_0» в массив «data».
				data[0] &= 0b11110111;																							//	Сбрасываем    бит «BLOCK_ADR».
				data[0] |= 0b00000010;																							//	Устанавливаем бит «SAVE_ADR_EN»
				if(_writeBytes(REG_BITS_0,1)==false){return false;}																//	Записываем 1 байт в регистр «BITS_0» из массива «data».
				data[0] = (newAddr<<1)|0x01;																					//	Готовим новый адрес к записи в модуль, установив бит «SAVE_FLASH».
				if(_writeBytes(REG_ADDRESS,1)==false){return false;}															//	Записываем 1 байт в регистр «ADDRESS» из массива «data».
				delay(200);																										//	Даём более чем достаточное время для применения модулем нового адреса.
			//	Проверяем наличие модуля с новым адресом на шине I2C:															//
				if(objI2C->checkAddress(newAddr)==false){return false;}															//	Если на шине I2C нет модуля с адресом newAddr, то возвращаем ошибку.
				valAddr     = newAddr;																							//	Сохраняем новый адрес как текущий.
				valAddrTemp = newAddr;																							//	Сохраняем новый адрес как указанный.
				return true;																									//	Возвращаем флаг успеха.
			}else{																												//	Иначе, если модуль не инициализирован, то ...
				return false;																									//	Возвращаем ошибку
			}																													//
}																																//
																																//
//		Получение флага наличия подтяжки линий шины I2C:																		//	Возвращаемое значение:	флаг наличия подтяжки линий шины I2C.
bool	iarduino_I2C_IR::getPullI2C			(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Считываем первые два регистра: регистр флагов и регистр битов:													//
				if(_readBytes(REG_FLAGS_0,2)==false ){ return false; }															//	Читаем 2 байта начиная с регистра «REG_FLAGS_0» в массив «data».
			//	Проверяем поддерживает ли модуль управление подтяжкой линий шины I2C:											//
				if( (data[0] & 0b00000100) == false ){ return false; }															//	Если флаг «FLG_I2C_UP» регистра «REG_FLAGS_0» сброшен, значит модуль не поддерживает управление подтяжкой линий шины I2C.
			//	Проверяем установлена ли подтяжка линий шины I2C:																//
				if( (data[1] & 0b00000100) == false ){ return false; }															//	Если бит  «SET_I2C_UP» регистра «REG_BITS_0»  сброшен, значит подтяжка линий шины I2C не установлена.
				return true;																									//	Возвращаем флаг успеха.
			}else{																												//	Иначе, если модуль не инициализирован, то ...
				return false;																									//	Возвращаем ошибку.
			}																													//
}																																//
																																//
//		Установка подтяжки линий шины I2C:																						//	Возвращаемое значение:	результат установки подтяжки линий шины I2C.
bool	iarduino_I2C_IR::setPullI2C			(bool f){																			//	Параметр:				флаг подтяжки линий шины I2C.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Считываем первые два регистра: регистр флагов и регистр битов:													//
				if(_readBytes(REG_FLAGS_0,2)==false ){ return false; }															//	Читаем 2 байта начиная с регистра «REG_FLAGS_0» в массив «data».
			//	Проверяем поддерживает ли модуль управление подтяжкой линий шины I2C:											//
				if( (data[0] & 0b00000100) == false ){ return false; }															//	Если флаг «FLG_I2C_UP» регистра «REG_FLAGS_0» сброшен, значит модуль не поддерживает управление подтяжкой линий шины I2C.
			//	Устанавливаем или сбрасываем бит включения подтяжки линий шины I2C:												//
				if(f){ data[0] = (data[1] |  0b00000100); }																		//	Если флаг «f» установлен, то копируем значение из 1 в 0 элемент массива «data» установив бит «SET_I2C_UP».
				else { data[0] = (data[1] & ~0b00000100); }																		//	Если флаг «f» сброшен   , то копируем значение из 1 в 0 элемент массива «data» сбросив   бит «SET_I2C_UP».
			//	Сохраняем получившееся значение в регистр «REG_BITS_0»:															//
				if(_writeBytes(REG_BITS_0,1)==false ){ return false; }															//	Записываем 1 байт в регистр «REG_BITS_0» из массива «data».
				delay(50);																										//	Даём время для сохранения данных в энергонезависимую память модуля.
				return true;																									//	Возвращаем флаг успеха.
			}else{																												//	Иначе, если модуль не инициализирован, то ...
				return false;																									//	Возвращаем ошибку
			}																													//
}																																//
																																//
//		УСТАНОВКА ПРОТОКОЛА ПЕРЕДАЧИ ДАННЫХ ПО ИК-КАНАЛУ:																		//	Возвращаемое значение:	результат установки протокола.
bool	iarduino_I2C_IR::setProtocol_TX		(uint8_t cod, uint8_t mode){														//	Параметр:				cod - протокол, mode - режим.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Готовим данные для передачи:																					//
				data[0] = ((mode<<5) & IR0_RC6_MODE) | (cod & IR0_NUM_CODING);													//	Готовим режим и номер ИК-протокола передачи данных для записи в модуль.
			//	Сохраняем получившееся значение в регистр «SEND_COD»:															//
				if(_writeBytes(REG_IR0_SEND_COD,1)==false ){ return false; }													//	Записываем 1 байт в регистр «SEND_COD» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		УСТАНОВКА ПРОТОКОЛА ПРИЁМА ДАННЫХ ПО ИК-КАНАЛУ:																			//	Возвращаемое значение:	результат установки протокола.
bool	iarduino_I2C_IR::setProtocol_RX		(uint8_t cod, uint8_t mode){														//	Параметр:				cod - протокол, mode - режим.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Готовим данные для передачи:																					//
				data[0] = ((mode<<5) & IR0_RC6_MODE) | (cod & IR0_NUM_CODING);													//	Готовим режим и номер ИК-протокола передачи данных для записи в модуль.
			//	Сохраняем получившееся значение в регистр «READ_COD»:															//
				if(_writeBytes(REG_IR0_READ_COD,1)==false ){ return false; }													//	Записываем 1 байт в регистр «READ_COD» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		ПОЛУЧЕНИЕ ПРОТОКОЛА ПЕРЕДАЧИ ДАННЫХ ПО ИК-КАНАЛУ:																		//	Возвращаемое значение:	протокол используемый для передачи данных по ИК-каналу.
uint8_t	iarduino_I2C_IR::getProtocol_TX		(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Читаем текущее значение регистра «SEND_COD»:																	//	
				if(_readBytes(REG_IR0_SEND_COD,1)==false ){ return IR_UNDEFINED; }												//	Читаем 1 байт из регистра «SEND_COD» в массив «data».
			//	Получаем номер протокола:																						//
				uint8_t i = (data[0] & IR0_NUM_CODING);																			//
			//	Получаем режим для протокола RC6:																				//
				modeRC6 = i==IR_RC6? ((data[0]&IR0_RC6_MODE)>>5):0;																//
			//	Возвращаем полученное значение:																					//
				return i;																										//	Возвращаем используемый протокол.
			}																													//
			return IR_UNDEFINED;																								//	Возвращаем значение указывающее что протокол не определён.
}																																//
																																//
//		ПОЛУЧЕНИЯ ПРОТОКОЛА ПРИЁМА ДАННЫХ ПО ИК-КАНАЛУ:																			//	Возвращаемое значение:	протокол используемый для приёма данных по ИК-каналу.
uint8_t	iarduino_I2C_IR::getProtocol_RX		(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Читаем текущее значение регистра «READ_COD»:																	//	
				if(_readBytes(REG_IR0_READ_COD,1)==false ){ return IR_UNDEFINED; }												//	Читаем 1 байт из регистра «READ_COD» в массив «data».
			//	Получаем номер протокола:																						//
				uint8_t i = (data[0] & IR0_NUM_CODING);																			//
			//	Получаем режим для протокола RC6:																				//
				modeRC6 = i==IR_RC6? ((data[0]&IR0_RC6_MODE)>>5):0;																//
			//	Возвращаем полученное значение:																					//
				return i;																										//	Возвращаем используемый протокол.
			}																													//
			return IR_UNDEFINED;																								//	Возвращаем значение указывающее что протокол не определён.
}																																//
																																//
//		ОПРЕДЕЛЕНИЕ ПРОТОКОЛА ПРИНИМАЕМЫХ ДАННЫХ ПО ИК-КАНАЛУ:																	//	Возвращаемое значение:	результат установки.
bool	iarduino_I2C_IR::seeProtocol_RX		(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Сбрасываем протокол принимаемых данных:																			//
				data[0]=0; if(_writeBytes(REG_IR0_READ_COD,1)==false ){ return false; }											//	Записываем 1 байт в регистр «READ_COD» из массива «data».
			//	Читаем текущее значение регистра «BIT»:																			//	
				if(_readBytes(REG_IR0_BIT,1)==false ){ return false; }															//	Читаем 1 байт из регистра «BIT» в массив «data».
				data[0] |= IR0_BIT_DETECT;																						//	Устанавливаем бит «DETECT».
			//	Сохраняем 1 байт в регистр «BIT»:																				//
				if(_writeBytes(REG_IR0_BIT,1)==false ){ return false; }															//	Записываем 1 байт в регистр «BIT» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		УСТАНОВКА ИНТЕРВАЛА МЕЖДУ ОТПРАВКОЙ ПАКЕТОВ ПОВТОРОВ:																	//	Возвращаемое значение:	результат установки.
bool	iarduino_I2C_IR::setInterval_TX		(uint8_t tim, bool flg){															//	Параметр:				tim - интервал 0 или 24-255 мс, flg - флаг плавающего итервала ±50%.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
				if( (tim>0) && (tim<24) ){ tim=24; }																			//	Не позволяем задавать интервалы между пакетами от 1 до 23 мс.
			//	Читаем текущее значение регистра «SEND_RPT»:																	//	
				if(_readBytes(REG_IR0_SEND_RPT,1)==false ){ return false; }														//	Читаем 1 байт из регистра «SEND_RPT» в массив «data».
			//	Корректируем полученные данные:																					//
				data[0] &=        IR0_BIT_REPEAT;																				//	Сохраняем состояние флага «REPEAT».
				data[0] |= (tim&(~IR0_BIT_REPEAT));																				//	Добавляем интервал между отправкой пакетов повторов.
			//	Сохраняем 1 байт в регистр «SEND_RPT»:																				//
				if(_writeBytes(REG_IR0_SEND_RPT,1)==false ){ return false; }													//	Записываем 1 байт в регистр «SEND_RPT» из массива «data».
			//	Читаем текущее значение регистра «BIT»:																			//	
				if(_readBytes(REG_IR0_BIT,1)==false ){ return false; }															//	Читаем 1 байт из регистра «BIT» в массив «data».
			//	Корректируем полученные данные:																					//
				if(flg){data[0] |= IR0_BIT_TX_SHIFT;}																			//	Устанавливаем бит «TX_SHIFT».
				else   {data[0] &=~IR0_BIT_TX_SHIFT;}																			//	Сбрасываем    бит «TX_SHIFT».
			//	Сохраняем 1 байт в регистр «BIT»:																				//
				if(_writeBytes(REG_IR0_BIT,1)==false ){ return false; }															//	Записываем 1 байт в регистр «BIT» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		УСТАНОВКА МАКСИМАЛЬНОГО ВРЕМЕНИ ОЖИДАНИЯ ПАКЕТА ПОВТОРА:																//	Возвращаемое значение:	результат установки.
bool	iarduino_I2C_IR::setInterval_RX		(uint8_t tim){																		//	Параметр:				tim - время ожидания 0 или 15-255 мс.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Читаем текущее значение регистра «READ_RPT»:																	//	
				if(_readBytes(REG_IR0_READ_RPT,1)==false ){ return false; }														//	Читаем 1 байт из регистра «READ_RPT» в массив «data».
			//	Корректируем полученные данные:																					//
				data[0] &=        IR0_BIT_REPEAT;																				//	Сохраняем состояние флага «REPEAT».
				data[0] |= (tim&(~IR0_BIT_REPEAT));																				//	Добавляем время ожидания пакета повтора.
			//	Сохраняем 1 байт в регистр «READ_RPT»:																			//
				if(_writeBytes(REG_IR0_READ_RPT,1)==false ){ return false; }													//	Записываем 1 байт в регистр «READ_RPT» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
}																																//
																																//
//		ОТПРАВКА АДРЕСА И КОМАНДЫ ПО ИК-КАНАЛУ ОДНОКРАТНО:																		//	Возвращаемое значение:	результат установки.
bool	iarduino_I2C_IR::send				(uint8_t adr, uint8_t com){															//	Параметры:				adr - адрес, com - команда.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Читаем текущее значение регистра «SEND_RPT»:																	//	
				if(_readBytes(REG_IR0_SEND_RPT,1)==false ){ return false; }														//	Читаем 1 байт из регистра «SEND_RPT» в массив «data».
			//	Определяем значения регистров повтора, адреса и команды для ИК-устройства:										//
				data[0] &= ~IR0_BIT_REPEAT;																						//	Определяем значение для регистра «SEND_RPT»: Сбрасываем бит отправки пакетов повтора «REPEAT».
				data[1]  =  adr;																								//	Определяем значение для регистра «SEND_ADR»: Адрес   ИК-устройства.
				data[2]  =  com;																								//	Определяем значение для регистра «SEND_COM»: Команда ИК-устройства.
			//	Сохраняем 3 байта полученных значений в регистры модуля:														//
				if(_writeBytes(REG_IR0_SEND_RPT,3)==false ){ return false; }													//	Записываем 3 байта в модуль, начиная с регистра «SEND_RPT» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		ОТПРАВКА КОДА ПО ИК-КАНАЛУ ОДНОКРАТНО:																					//	Возвращаемое значение:	результат установки.
bool	iarduino_I2C_IR::send32				(uint32_t cod32){																	//	Параметр:				cod32 - код для передачи.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Читаем номер протокола используемого для передачи данных:														//
				uint8_t adr, com, i=getProtocol_TX();																			//
			//	Преобразуем код «cod32» в адрес «adr» и команду «com» в соответствии с протоколом «i»:							//
				_coder32(i, &cod32, &adr, &com, 1);																				//	Последний параметр - флаг направления преобразований: 0 - адрес и команду в код32 / 1 - код32 в адрес и команду.
			//	Отправляем адрес «adr» и команду «com» по ИК-каналу однократно:													//
				if( adr || com ){ return send(adr, com); }																		//	
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		ОТПРАВКИ АДРЕСА И КОМАНДЫ ПО ИК-КАНАЛУ ПОСТОЯННО:																		//	Возвращаемое значение:	результат установки.
bool	iarduino_I2C_IR::autoSend			(uint8_t adr, uint8_t com){															//	Параметры:				adr - адрес, com - команда.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Читаем текущее значение регистра «SEND_RPT»:																	//	
				if(_readBytes(REG_IR0_SEND_RPT,1)==false ){ return false; }														//	Читаем 1 байт из регистра «SEND_RPT» в массив «data».
			//	Определяем значения регистров повтора, адреса и команды для ИК-устройства:										//
				data[0] |= IR0_BIT_REPEAT;																						//	Определяем значение для регистра «SEND_RPT»: Устанавливаем бит отправки пакетов повтора «REPEAT».
				data[1]  = adr;																									//	Определяем значение для регистра «SEND_ADR»: Адрес   ИК-устройства.
				data[2]  = com;																									//	Определяем значение для регистра «SEND_COM»: Команда ИК-устройства.
			//	Сохраняем 3 байта полученных значений в регистры модуля:														//
				if(_writeBytes(REG_IR0_SEND_RPT,3)==false ){ return false; }													//	Записываем 3 байта в модуль, начиная с регистра «SEND_RPT» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		ОТПРАВКИ КОДА ПО ИК-КАНАЛУ ПОСТОЯННО:																					//	Возвращаемое значение:	результат установки.
bool	iarduino_I2C_IR::autoSend32			(uint32_t cod32){																	//	Параметр:				cod32 - код для передачи.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Читаем номер протокола используемого для передачи данных:														//
				uint8_t adr, com, i=getProtocol_TX();																			//
			//	Преобразуем код «cod32» в адрес «adr» и команду «com» в соответствии с протоколом «i»:							//
				_coder32(i, &cod32, &adr, &com, 1);																				//	Последний параметр - флаг направления преобразований: 0 - адрес и команду в код32 / 1 - код32 в адрес и команду.
			//	Отправляем адрес «adr» и команду «com» по ИК-каналу постоянно:													//
				if( adr || com ){ return autoSend(adr, com); }																	//	
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		ОЖИДАНИЕ ЗАВЕРШЕНИЯ ОДНОКРАТНОЙ ОТПРАВКИ:																				//	Возвращаемое значение:	результат установки.
void	iarduino_I2C_IR::wait				(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
				uint32_t tim    = millis();																						//	
				        data[0] = IR0_BIT_TX_BUSY;																				//	
				while( (data[0] & IR0_BIT_TX_BUSY) && ((millis()-500)<tim) ){ _readBytes(REG_IR0_BIT,1); }						//	Читаем 1 байт из регистра «BIT» в массив «data», пока не будет сброшен бит «TX_BUSY» или не проёдет 500 мс.
			}																													//
}																																//
																																//
//		ОСТАНОВКА ПОСТОЯННОЙ ОТПРАВКИ ИНФОРМАЦИИ:																				//	Возвращаемое значение:	результат установки.
bool	iarduino_I2C_IR::autoStop			(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Читаем текущее значение регистра «SEND_RPT»:																	//	
				if(_readBytes(REG_IR0_SEND_RPT,1)==false ){ return false; }														//	Читаем 1 байт из регистра «SEND_RPT» в массив «data».
				data[0] &= ~IR0_BIT_REPEAT;																						//	Определяем значение для регистра «SEND_RPT»: Сбрасываем бит отправки пакетов повтора «REPEAT».
			//	Сохраняем 1 байт в регистр «SEND_RPT»:																			//
				if(_writeBytes(REG_IR0_SEND_RPT,1)==false ){ return false; }													//	Записываем 1 байт в регистр «SEND_RPT» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
																																//
//		ПРОВЕРКА НАЛИЧИЯ ПРИНЯТЫХ ПО ИК-КАНАЛУ ДАННЫХ:																			//	Возвращаемое значение:	результат установки.
bool	iarduino_I2C_IR::check				(bool flg){																			//	Параметр:				flg - флаг указывающий реагировать на пакеты повтора.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Читаем значение регистров «READ_RPT», «READ_ADR» и «READ_COM»:													//	
				if(_readBytes(REG_IR0_READ_RPT,3)==false ){ return false; }														//	Читаем 3 байта из модуля в массив «data» начиная с регистра «READ_RPT».
			//	Если в модуле есть данные полученные по ИК-каналу:																//
				if( data[1] || data[2] ){																						//	Если значение регистра «READ_ADR» или «READ_COM» отлическтся от 0, то ...
					uint8_t i;																									//
				//	Игнорируем пакеты повторов																					//
					if( !flg && (data[0]&IR0_BIT_REPEAT) ){ return false; }														//	Выходим из функции если запрещено реагировать на пакеты повтора («flg»=0), а в регистре «READ_RPT» установлен бит «REPEAT».
				//	Готовим данные для пользователя:																			//
					address		=	data[1];																					//	Сохраняем байт адреса ИК-устройства.
					command		=	data[2];																					//	Сохраняем байт команды ИК-устройства.
					code		=	data[1]; code<<=8; code|=data[2];															//	Сохраняем двухбайтное число из байта адреса и байта команды ИК-устройства.
					key_press	=	(data[0]&IR0_BIT_REPEAT)? 0:1;																//  Определяем флаг указвающий на то, что кнопка пульта нажимается а не удерживается.
				//	Готовим данные для совместимости с библиотекой iarduino_IR:													//
					i=getProtocol_RX();																							//	Читаем номер протокола используемого для приёма данных.
					_coder32(i, &code32, &address, &command, 0);																//	Преобразуем адрес и команду в 32 битный код (последний параметр - флаг направления преобразований: 0 - адрес и команду в код32 / 1 - код32 в адрес и команду).
					if(i==4){length=12;} if(i==6||i==7){length=13;} if(i==3||i==5){length=15;} if(i==8){length=20;} if(i==1||i==2){length=32;} if(i==9){length=33;}
				//	Сбрасываем состояния светофоров и знаков модулей линейки «Дорожное движение»:								//
					device		=	0;																							//	Предварительно указываем что модули линейки «Дорожное движение» не обнаружены.
					track_F		=	0;																							//	Предварительно указываем что на перекрёстке управляемом светофором нет дороги прямо.
					track_R		=	0;																							//	Предварительно указываем что на перекрёстке управляемом светофором нет дороги направо.
					track_L		=	0;																							//	Предварительно указываем что на перекрёстке управляемом светофором нет дороги налево.
					forvard		=	0;																							//	Предварительно указываем что от светофора линейки «Дорожное движение» не поступило команды разрешающей движение прямо.
					right		=	0;																							//	Предварительно указываем что от светофора линейки «Дорожное движение» не поступило команды разрешающей движение справо.
					left		=	0;																							//	Предварительно указываем что от светофора линейки «Дорожное движение» не поступило команды разрешающей движение влево.
					gate		=	0;																							//	Предварительно указываем что шлагбаум линейки «Дорожное движение» закрыт.
					sign[0]		=	0;																							//	Предварительно указываем что у знака нет номера группы.
					sign[1]		=	0;																							//	Предварительно указываем что у знака нет номера.
					sign[2]		=	0;																							//	Предварительно указываем что у знака нет пункта номера.
					sign_str[0]	=	0;																							//	Предварительно указываем что строковое обозначение знака линейки «Дорожное движение» неизвестно.
					sign_int	=	0;																							//	Предварительно указываем что числовое обозначение знака линейки «Дорожное движение» неизвестно.
					sign_tab	=	0;																							//	Предварительно указываем что под знаком линейки «Дорожное движение» нет таблички уточняющей или ограничивающей его действие.
				//	Определяем данные передаваемые автомобилем:																	//
					if( address==MODUL_CAR){device		= MODUL_CAR; }															//
				//	Определяем данные передаваемые светофором линейки «Дорожное движение»:										//
					if( (address>0x03) && (address<0x20) ){																		//
											device		= MODUL_TLIGHT;															//
											track_F		= (address & TRACK_F)? 1:0;												//	Флаг наличия дороги прямо.
											track_R		= (address & TRACK_R)? 1:0;												//	Флаг наличия дороги направо.
											track_L		= (address & TRACK_L)? 1:0;												//	Флаг наличия дороги налево.
											gate		= (command & 0x80)? 0:1;												//	0x80 =  1   0    0    0    0    0   0   0     GAT   - указывает на то что шлагбаум закрыт.
					//	У светофора нет секций управления поворотами:															//
						if( !(address&SECTION_L) && !(address&SECTION_R) ){														//	       GAT RED YELBL YEL GRNBL GRN LEF RGT
											forvard		= (command & 0x0C)? 1:0;												//	0x0C =  0   0    0    0    1    1   0   0     GRNBL - мигающий зелёный, GRN - зелёный.
											right   	= (command & 0x0C)? 1:0;												//	0x0C =  0   0    0    0    1    1   0   0     GRNBL - мигающий зелёный, GRN - зелёный.
											left		= (command & 0x0C)? 2:0;												//	0x0C =  0   0    0    0    1    1   0   0     GRNBL - мигающий зелёный, GRN - зелёный.
						}																										//
					//	У светофора есть секция управления правым поворотом:													//
						if( !(address&SECTION_L) &&  (address&SECTION_R) ){														//	       GAT RED YELBL YEL GRNBL GRN LEF RGT
											forvard		= (command & 0x0C)? 1:0;												//	0x0C =  0   0    0    0    1    1   0   0     GRNBL - мигающий зелёный, GRN - зелёный.
											right   	= (command & 0x01)? 1:0;												//	0x01 =  0   0    0    0    0    0   0   1     RGT   - стрелка вправо.
											left		= (command & 0x0C)? 2:0;												//	0x0C =  0   0    0    0    1    1   0   0     GRNBL - мигающий зелёный, GRN - зелёный.
						}																										//
					//	У светофора есть секция управления левым поворотом:														//
						if(  (address&SECTION_L) && !(address&SECTION_R) ){														//	       GAT RED YELBL YEL GRNBL GRN LEF RGT
											forvard		= (command & 0x0C)? 1:0;												//	0x0C =  0   0    0    0    1    1   0   0     GRNBL - мигающий зелёный, GRN - зелёный.
											right   	= (command & 0x0C)? 1:0;												//	0x0C =  0   0    0    0    1    1   0   0     GRNBL - мигающий зелёный, GRN - зелёный.
											left    	= (command & 0x02)? 1:0;												//	0x02 =  0   0    0    0    0    0   1   0     LEF   - стрелка влево.
						}																										//
					//	У светофора есть секция управления левым и правым поворотом:											//
						if(  (address&SECTION_L) &&  (address&SECTION_R) ){														//	       GAT RED YELBL YEL GRNBL GRN LEF RGT
											forvard		= (command & 0x0C)? 1:0;												//	0x0C =  0   0    0    0    1    1   0   0     GRNBL - мигающий зелёный, GRN - зелёный.
											right   	= (command & 0x01)? 1:0;												//	0x01 =  0   0    0    0    0    0   0   1     RGT   - стрелка вправо.
											left    	= (command & 0x02)? 1:0;												//	0x02 =  0   0    0    0    0    0   1   0     LEF   - стрелка влево.
						}																										//
					//	Предупреждаем о том, что светофор не регулирует перекрёсток:											//	       GAT RED YELBL YEL GRNBL GRN LEF RGT
						if( command == 0x20 ){																					//	0x20 =  0   0    1    0    0    0   0   0     YELBL - мигающий жёлтый.
											forvard		= 2;																	//	                                                      Разрешаем движение
											right   	= 2;																	//	                                                      в любом направлении
											left    	= 2;																	//	                                                      если нет помех.
						}																										//
					//	Запрещаем движение если нет дороги или закрыт шлагбаум:													//
						if(!gate||!track_F){forvard		= 0;}																	//	Если нет дороги прямо  (track_F==0) или закрыт шлагбаум (gate==1), то запрещаем движение прямо  forvard=0.
						if(!gate||!track_R){right		= 0;}																	//	Если нет дороги впарво (track_R==0) или закрыт шлагбаум (gate==1), то запрещаем движение впарво right=0.
						if(!gate||!track_L){left		= 0;}																	//	Если нет дороги влево  (track_L==0) или закрыт шлагбаум (gate==1), то запрещаем движение влево  left=0.
					}																											//
				//	Определяем состояние знака линейки «Дорожное движение»:														//
					if( address>=0x20 ){	device		= MODUL_SIGN;  															//
											sign[0]		= (code >> 13) & 0b00000111;											//	Извлекаем группу знака. Число состоит из 3 бит и может принимать значение от 1 до 7  (в ПДД нет знаков с группой 0).
											sign[1]		= (code >> 7 ) & 0b00111111; if(sign[1]==0){device=0;}					//	Извлекаем номер  знака. Число состоит из 6 бит и может принимать значение от 1 до 63 (в ПДД нет знаков с номером 0).
											sign[2]		= (code >> 3 ) & 0b00001111;											//	Извлекаем пункт  знака. Число состоит из 4 бит и может принимать значение от 0 до 15 (если 0 значит у знака нет пункта).
											sign_tab	=  code        & 0b00000111;											//	Извлекаем информацию о табличке под знаком.
						if( sign_tab >0	){	sign_tab   +=  15;}																	//
											sign_int	= (uint16_t)sign[0]*10000 + (uint16_t)sign[1]*100 + (uint16_t)sign[2];	//	Объединяем группу, номер и пункт знака в одно число.
						uint8_t i=0;		sign_str[i]	= sign[0]%10+'0'; i++;													//	"7"			"7"
											sign_str[i]	= '.';            i++;													//	"7."		"7."
						if( sign[1]>=10 ){	sign_str[i]	= sign[1]/10+'0'; i++;}													//	"7.6"
											sign_str[i]	= sign[1]%10+'0'; i++;													//	"7.63"		"7.3"
						if( sign[2]>  0 ){	sign_str[i]	= '.';            i++;													//	"7.63."		"7.3."
						if( sign[2]>=10 ){	sign_str[i]	= sign[2]/10+'0'; i++;}													//	"7.63.1"
											sign_str[i]	= sign[2]%10+'0'; i++;													//	"7.63.15"	"7.3.5"
						}					sign_str[i]	= 0;																	//	Добавляем символ конца строки.
					}																											//
					return true;																								//	Возвращаем флаг успеха.
				}																												//
			}																													//
			return false;																										//	Возвращаем ошибку.
}																																//
//		ПЕРЕВОРОТ БИТОВ БАЙТА:																									//	Возвращаемое значение:	байт биты которого следуют в обратном порядке.
uint8_t iarduino_I2C_IR::_flip				(uint8_t i){																		//	Параметры:				i - байт биты которого нужно перевернуть.
			return 	( ((i>>7)&1)<<0 )|																							//	Возвращаем 7 бит в 0 разряде.
					( ((i>>6)&1)<<1 )|																							//	Возвращаем 6 бит в 1 разряде.
					( ((i>>5)&1)<<2 )|																							//	Возвращаем 5 бит в 2 разряде.
					( ((i>>4)&1)<<3 )|																							//	Возвращаем 4 бит в 3 разряде.
					( ((i>>3)&1)<<4 )|																							//	Возвращаем 3 бит в 4 разряде.
					( ((i>>2)&1)<<5 )|																							//	Возвращаем 2 бит в 5 разряде.
					( ((i>>1)&1)<<6 )|																							//	Возвращаем 1 бит в 6 разряде.
					( ((i>>0)&1)<<7 );																							//	Возвращаем 0 бит в 7 разряде.
}																																//
																																//
//		ПРЕОБРАЗОВАНИЕ АДРЕСА И КОМАНДЫ В 32 БИТНЫЙ КОД И ОБРАТНО:																//	Возвращаемое значение:	нет.
void	iarduino_I2C_IR::_coder32			(uint8_t cod, uint32_t* cod32, uint8_t* adr, uint8_t* com, bool flg){				//	Параметры:				кодировка, код, адрес, команда, флаг направления преобразований.
			if(flg){																											//
			//	Преобразуем код «cod32» в адрес «adr» и команду «com» в соответствии с протоколом «cod»:						//
				if( cod==IR_NEC			){	*adr=(_flip(*cod32>>24)   )&0xFF;	*com=(_flip(*cod32>> 8)   )&0xFF; }				//	[lsb (uint8_t) ADR msb] [lsb (uint8_t) ~ADR msb] [lsb (uint8_t)  COM msb] [lsb (uint8_t) ~COM msb]
				if( cod==IR_SAMSUNG		){	*adr=(_flip(*cod32>>24)   )&0xFF;	*com=(_flip(*cod32>> 8)   )&0xFF; }				//	[lsb (uint8_t) ADR msb] [lsb (uint8_t)  ADR msb] [lsb (uint8_t)  COM msb] [lsb (uint8_t) ~COM msb]
				if( cod==IR_SHARP		){	*adr=(_flip(*cod32>>10)>>3)&0x1F;	*com=(_flip(*cod32>> 2)   )&0xFF; }				//	                                                 [lsb (uint5_t)  ADR msb] [lsb (uint8_t)  COM msb] [0b01]
				if( cod==IR_SIRC12		){	*adr=(_flip(*cod32    )>>3)&0x1F;	*com=(_flip(*cod32>> 5)>>1)&0x7F; }				//	                                                 [lsb (uint7_t)  COM msb] [lsb (uint5_t)  ADR msb]
				if( cod==IR_SIRC15		){	*adr=(_flip(*cod32    )>>3)&0x1F;	*com=(_flip(*cod32>> 7)   )&0xFF; }				//	                                                 [lsb (uint10_t) COM msb] [lsb (uint5_t)  ADR msb]
				if( cod==IR_RC5			){	*adr=(     (*cod32>> 6)   )&0x1F;	*com=(     (*cod32    )   )&0x3F; }				//	                                          [0b11] [msb (uint5_t)  ADR lsb] [msb (uint6_t)  COM lsb]
				if( cod==IR_RC5X		){	*adr=(     (*cod32>> 7)   )&0x1F;	*com=(     (*cod32    )   )&0x7F; }				//	                                           [0b1] [msb (uint5_t)  ADR lsb] [msb (uint7_t)  COM lsb]
				if( cod==IR_RC6			){	*adr=(     (*cod32>> 8)   )&0xFF;	*com=(     (*cod32    )   )&0xFF; }				//	                  [0b1] [msb (uint3_t)  MOD lsb] [msb (uint8_t)  ADR lsb] [msb (uint8_t)  COM lsb]
				if( cod==IR_IARDUINO	){	*adr=(_flip(*cod32>>24)   )&0xFF;	*com=(_flip(*cod32>>16)   )&0xFF; }				//	[lsb (uint8_t) ADR msb] [lsb (uint8_t)  COM msb] [lsb (uint8_t) ~ADR msb] [lsb (uint8_t) ~COM msb]
			}else{																												//
			//	Преобразуем адрес «adr» и команду «com» в код «cod32» в соответствии с протоколом «cod»:						//
				if( cod==IR_NEC			){	*cod32 = ((uint32_t)_flip(*adr)<<24) | ((uint32_t)_flip(~*adr)<<16) | (( (uint32_t)_flip( *com)         )<< 8) |   _flip(~*com);                 }
				if( cod==IR_SAMSUNG		){	*cod32 = ((uint32_t)_flip(*adr)<<24) | ((uint32_t)_flip( *adr)<<16) | (( (uint32_t)_flip( *com)         )<< 8) |   _flip(~*com);                 }
				if( cod==IR_SHARP		){	*cod32 =                                                              ((((uint32_t)_flip( *adr)>>3)&0x1F)<<10) | ( _flip( *com)      <<2) | 0b10;}
				if( cod==IR_SIRC12		){	*cod32 =                                                              ((((uint32_t)_flip( *com)>>1)&0x7F)<< 5) | ((_flip( *adr)>>3)&0x1F);       }
				if( cod==IR_SIRC15		){  *cod32 =                                                              (( (uint32_t)_flip( *com)         )<< 7) | ((_flip( *adr)>>3)&0x1F);       }
				if( cod==IR_RC5			){  *cod32 =                                                0x00001800L | (( (uint32_t)       *adr     &0x1F)<< 6) | (        *com     &0x3F);       }
				if( cod==IR_RC5X		){  *cod32 =                                                0x00001000L | (( (uint32_t)       *adr     &0x1F)<< 7) | (        *com     &0x7F);       }
				if( cod==IR_RC6			){	*cod32 =                                                0x00080000L | (  (uint32_t)       *adr           << 8) |          *com;                  }
				if( cod==IR_IARDUINO	){	*cod32 = ((uint32_t)_flip(*adr)<<24) | ((uint32_t)_flip( *com)<<16) | (  (uint32_t)_flip(~*adr)          << 8) |   _flip(~*com);                 }
			}																													//
}																																//
																																//
//		Чтение данных из регистров в массив data:																				//	Возвращаемое значение:	результат чтения (true/false).
bool	iarduino_I2C_IR::_readBytes			(uint8_t reg, uint8_t sum){															//	Параметры:				reg - номер первого регистра, sum - количество читаемых байт.
			bool	result=false;																								//	Определяем флаг       для хранения результата чтения.
			uint8_t	sumtry=10;																									//	Определяем переменную для подсчёта количества оставшихся попыток чтения.
			do{	result = objI2C->readBytes(valAddr, reg, data, sum);															//	Считываем из модуля valAddr, начиная с регистра reg, в массив data, sum байт.
				sumtry--;	if(!result){delay(1);}																				//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
			}	while		(!result && sumtry>0);																				//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
			delayMicroseconds(500);																								//	Между пакетами необходимо выдерживать паузу.
			return result;																										//	Возвращаем результат чтения (true/false).
}																																//
																																//
//		Запись данных в регистры из массива data:																				//	Возвращаемое значение:	результат записи (true/false).
bool	iarduino_I2C_IR::_writeBytes		(uint8_t reg, uint8_t sum, uint8_t num){											//	Параметры:				reg - номер первого регистра, sum - количество записываемых байт, num - номер первого элемента массива data.
			bool	result=false;																								//	Определяем флаг       для хранения результата записи.
			uint8_t	sumtry=10;																									//	Определяем переменную для подсчёта количества оставшихся попыток записи.
			do{	result = objI2C->writeBytes(valAddr, reg, &data[num], sum);														//	Записываем в модуль valAddr начиная с регистра reg, sum байи из массива data начиная с элемента num.
				sumtry--;	if(!result){delay(1);}																				//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
			}	while		(!result && sumtry>0);																				//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
			delay(10);																											//	Ждём применения модулем записанных данных.
			return result;																										//	Возвращаем результат записи (true/false).
}																																//
																																//