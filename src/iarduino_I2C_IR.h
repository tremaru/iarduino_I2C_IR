//	Библиотека для работы с Trema модулем ИК-приёмник/передатчик, I2C-flash для Arduino: https://iarduino.ru/shop/Expansion-payments/ik-priemnik-peredatchik-flash-i2c.html
//  Версия: 1.0.2
//  Последнюю версию библиотеки Вы можете скачать по ссылке: https://iarduino.ru/file/547.html
//  Подробное описание функций бибилиотеки доступно по ссылке: https://wiki.iarduino.ru/page/ir-i2c/
//  Библиотека является собственностью интернет магазина iarduino.ru и может свободно использоваться и распространяться!
//  При публикации устройств или скетчей с использованием данной библиотеки, как целиком, так и её частей,
//  в том числе и в некоммерческих целях, просим Вас опубликовать ссылку: http://iarduino.ru
//  Автор библиотеки: Панькин Павел.
//  Если у Вас возникли технические вопросы, напишите нам: shop@iarduino.ru

#ifndef iarduino_I2C_IR_h																						//
#define iarduino_I2C_IR_h																						//
																												//
#if defined(ARDUINO) && (ARDUINO >= 100)																		//
#include		<Arduino.h>																						//
#else																											//
#include		<WProgram.h>																					//
#endif																											//
																												//
#include		<iarduino_I2C_IR_I2C.h>																			//	Подключаем файл iarduino_I2C_IR_I2C.h - для работы с шиной I2C		(используя функции структуры iI2C)
																												//
#define			DEF_CHIP_ID_FLASH		0x3C																	//	ID линейки чипов - константа для всех чипов серии Flash (позволяет идентифицировать принадлежность чипа к серии).
#define			DEF_CHIP_ID_METRO		0xC3																	//	ID линейки чипов - константа для всех чипов серии Metro (позволяет идентифицировать принадлежность чипа к серии).
#define			DEF_MODEL_IR0			0x17																	//	Идентификатор модели - константа.
#define			DEF_MODEL_IR1			0x18																	//	Идентификатор модели - константа.
//				Адреса регистров модуля:																		//
#define			REG_FLAGS_0				0x00																	//	Адрес регистра флагов управления для чтения.
#define			REG_BITS_0				0x01																	//	Адрес регистра битов  управления для чтения и записи.
#define			REG_FLAGS_1				0x02																	//	Адрес регистра флагов управления для чтения.
#define			REG_BITS_1				0x03																	//	Адрес регистра битов  управления для чтения и записи.
#define			REG_MODEL				0x04																	//	Адрес регистра содержащего номер типа модуля.
#define			REG_VERSION				0x05																	//	Адрес регистра содержащего версию прошивки.
#define			REG_ADDRESS				0x06																	//	Адрес регистра содержащего текущий адрес модуля на шине I2C. Если адрес указан с флагом IF-PIN-ADDRES то адрес установится (и запишется в регистр) только при наличии 1 на входе PIN_ADDRES.
#define			REG_CHIP_ID				0x07																	//	Адрес регистра содержащего ID линейки чипов «Flash». По данному ID можно определить принадлежность чипа к линейки «Flash».
#define			REG_IR0_SEND_RPT		0x10																	//	Адрес регистра содержащего минимальное время между отправляемыми пакетами повторов в мс * 2 (значение 1=2мс, 2=4мс, ... , 127=254мс, значение 0 указывает использовать интервал протокола по умолчанию). Последний бит регистра указывает передавать пакеты повтора, пока этот бит не будет сброшен.
#define			REG_IR0_SEND_ADR		0x11																	//	Адрес регистра содержащего байт адреса  устройства для передачи по ИК-каналу.
#define			REG_IR0_SEND_COM		0x12																	//	Адрес регистра содержащего байт команды устройству для передачи по ИК-каналу.
#define			REG_IR0_SEND_COD		0x13																	//	Адрес регистра содержащего номер протокола используемого для передачи данных по ИК-каналу.
#define			REG_IR0_READ_RPT		0x14																	//	Адрес регистра содержащего максимальное время ожидания пакетов повторов в мс * 2 (значение 1=2мс, 2=4мс, ... , 127=254мс, значение 0 указывает использовать интервал протокола по умолчанию). Последний бит регистра указывает на получение пакета повтора.
#define			REG_IR0_READ_ADR		0x15																	//	Адрес регистра содержащего байт адреса  устройства принятого по ИК-каналу.
#define			REG_IR0_READ_COM		0x16																	//	Адрес регистра содержащего байт команды устройству принятого по ИК-каналу.
#define			REG_IR0_READ_COD		0x17																	//	Адрес регистра содержащего номер протокола используемого для получения данных по ИК-каналу.
#define			REG_IR0_BIT				0x18																	//	Адрес регистра содержащего биты управления ИК-каналом.
//				Позиция битов и флагов:																			//
#define			IR0_BIT_REPEAT			0x01																	//	Бит  регистров SEND_RPT/READ_RPT указывает модулю отправлять пакеты повтора после отправки любого пакета, до тех пор, пока бит не будет сброшен / устанавливается при получении пакета повтора и сбрасывается при получении пакета данных или истечении времени ожидания пакета повтора.
#define			IR0_NUM_CODING			0x1F																	//	Биты регистров SEND_COD/READ_COD хранят номер протокола используемого для передачи/приёма данных.
#define			IR0_RC6_MODE			0xE0																	//	Биты регистров SEND_COD/READ_COD хранят номер режима используемого протоколом RC-6 для передачи/приёма данных.
#define			IR0_BIT_TX_BUSY			0x20																	//	Бит  регистра  REG_IR0_BIT       информирует о занятости ИК-передатчика.
#define			IR0_BIT_TX_SHIFT		0x08																	//	Бит  регистра  REG_IR0_BIT       указывает модулю самостоятельно и хаотично менять интервал между отправляемыми пакетами повторов в диапазоне ±50% от заданного.
#define			IR0_BIT_DETECT			0x04																	//	Бит  регистра  REG_IR0_BIT       указывает автоматически отпределить кодировку принимаемых данных. При определении кодировки полученного сигнала, бит сбросится автоматически, а в регистре «REG_IR0_READ_COD» появится номер обнаруженной кодировки.
#define			IR0_BIT_RX_EN			0x02																	//	Бит  регистра  REG_IR0_BIT       разрешает работу ИК-приёмника.
#define			IR0_BIT_TX_EN			0x01																	//	Бит  регистра  REG_IR0_BIT       разрешает работу ИК-передатчика.
#define			TRACK_L					0x10																	//	Бит  ИК-адреса светофора         указывает о наличии поворота налево.
#define			TRACK_F					0x08																	//	Бит  ИК-адреса светофора         указывает о наличии дороги прямо.
#define			TRACK_R					0x04																	//	Бит  ИК-адреса светофора         указывает о наличии поворота направо.
#define			SECTION_L				0x02																	//	Бит  ИК-адреса светофора         указывает о наличии секцией поворота влево.
#define			SECTION_R				0x01																	//	Бит  ИК-адреса светофора         указывает о наличии секцией поворота вправо.
//				Константы библиотеки:																			//
#define			MODUL_CAR				0x01																	//	device   == MODUL_CAR;           модуль принял данные от автомобиля трассы.
#define			MODUL_TLIGHT			0x02																	//	device   == MODUL_TLIGHT;        модуль принял данные от светофора линейки «Дорожное движение».
#define			MODUL_SIGN				0x03																	//	device   == MODUL_SIGN;          модуль принял данные от дорожного знака линейки «Дорожное движение».
#define			SIGN_CAR_TRUCK			15+1																	//	sign_tab == SIGN_CAR_TRUCK;      действие знака распространяется только на грузовые автомобили.
#define			SIGN_CAR_LIGHT			15+2																	//	sign_tab == SIGN_CAR_LIGHT;      действие знака распространяется только на легковые автомобили.
#define			SIGN_DISTANCE_050		15+3																	//	sign_tab == SIGN_DISTANCE_050;   расстояние до объекта или зона действия знака определена расстоянием в  50 метров.
#define			SIGN_DISTANCE_100		15+4																	//	sign_tab == SIGN_DISTANCE_100;   расстояние до объекта или зона действия знака определена расстоянием в 100 метров.
#define			SIGN_DISTANCE_150		15+5																	//	sign_tab == SIGN_DISTANCE_150;   расстояние до объекта или зона действия знака определена расстоянием в 150 метров.
#define			SIGN_DISTANCE_200		15+6																	//	sign_tab == SIGN_DISTANCE_200;   расстояние до объекта или зона действия знака определена расстоянием в 200 метров.
#define			SIGN_DISTANCE_250		15+7																	//	sign_tab == SIGN_DISTANCE_250;   расстояние до объекта или зона действия знака определена расстоянием в 250 метров.
#define			IR_UNDEFINED			0	//																	//	set/getProtocol_RX/TX();         сбросить ИК-протокол / узнать что ИК-протокол не определён.
#define			IR_NEC					1	//	NEC																//	set/getProtocol_RX/TX();         установить/получить ИК-протокол приёма/передачи данных NEC         (кодирование длинной паузы).
#define			IR_SAMSUNG				2	//	SAMSUNG															//	set/getProtocol_RX/TX();         установить/получить ИК-протокол приёма/передачи данных SAMSUNG     (кодирование длинной паузы).
#define			IR_SHARP				3	//	SHARP															//	set/getProtocol_RX/TX();         установить/получить ИК-протокол приёма/передачи данных SHARP       (кодирование длинной паузы).
#define			IR_SIRC12				4	//	SONY															//	set/getProtocol_RX/TX();         установить/получить ИК-протокол приёма/передачи данных SIRC12      (кодирование длинной импульса).
#define			IR_SIRC15				5	//	SONY															//	set/getProtocol_RX/TX();         установить/получить ИК-протокол приёма/передачи данных SIRC15      (кодирование длинной импульса).
#define			IR_RC5					6	//	PHILIPS															//	set/getProtocol_RX/TX();         установить/получить ИК-протокол приёма/передачи данных RC5         (бифазное кодирование).
#define			IR_RC5X					7	//	PHILIPS															//	set/getProtocol_RX/TX();         установить/получить ИК-протокол приёма/передачи данных RC5X        (бифазное кодирование).
#define			IR_RC6					8	//	PHILIPS															//	set/getProtocol_RX/TX();         установить/получить ИК-протокол приёма/передачи данных RC6         (бифазное кодирование)
#define			IR_IARDUINO				9	//	IARDUINO														//	set/getProtocol_RX/TX();         установить/получить ИК-протокол приёма/передачи данных IR_IARDUINO (кодирование длинной паузы).
																												//
class iarduino_I2C_IR{																							//
	public:																										//
	/**	Конструктор класса **/																					//
		iarduino_I2C_IR							(uint8_t address=0){											//	Конструктор класса														(Параметр: адрес модуля на шине I2C, если не указан (=0), то адрес будет определён).
													if(address>0x7F){ address>>=1; }							//	Корректируем адрес, если он указан с учётом бита RW.
							valAddrTemp			=	address;													//	Сохраняем переданный адрес модуля.
							objI2C				=	new iarduino_I2C;											//	Переопределяем указатель objI2C на объект производного класса iarduino_I2C.
		}																										//
	/**	Пользовательские функции **/																			//
		bool				begin				(void					);										//	Объявляем  функцию инициализации модуля									(Параметр:  отсутствует).
		bool				reset				(void					);										//	Объявляем  функцию перезагрузки модуля									(Параметр:  отсутствует).
		bool				changeAddress		(uint8_t				);										//	Объявляем  функцию смены адреса модуля на шине I2C						(Параметр:  новый адрес модуля).
		uint8_t				getAddress			(void					){ return valAddr;	}					//	Определяем функцию возвращающую текущий адрес модуля на шине I2C		(Параметр:  отсутствует).
		uint8_t				getVersion			(void					){ return valVers;	}					//	Определяем функцию возвращающую текущую версию прошивки модуля			(Параметр:  отсутствует).
		bool				getPullI2C			(void					);										//	Объявляем  функцию возвращающую флаг наличия подтяжки шины I2C			(Параметр:  отсутствует).
		bool				setPullI2C			(bool=true				);										//	Объявляем  функцию установки    подтяжки шины I2C						(Параметр:  флаг подтяжки).
		bool				setProtocol_TX		(uint8_t, uint8_t=0		);										//	Объявляем  функцию установки    протокола передачи данных по ИК-каналу	(Параметр:  протокол, режим).
		bool				setProtocol_RX		(uint8_t, uint8_t=0		);										//	Объявляем  функцию установки    протокола приёма   данных по ИК-каналу	(Параметр:  протокол, режим).
		uint8_t				getProtocol_TX		(void					);										//	Объявляем  функцию получения    протокола передачи данных по ИК-каналу	(Параметр:  отсутствует).
		uint8_t				getProtocol_RX		(void					);										//	Объявляем  функцию получения    протокола приёма   данных по ИК-каналу	(Параметр:  отсутствует).
		bool				seeProtocol_RX		(void					);										//	Объявляем  функцию определения  протокола приёма   данных по ИК-каналу	(Параметр:  отсутствует).
		bool				setInterval_TX		(uint8_t, bool=false	);										//	Объявляем  функцию установки    интервала между отправкой пакетов пвт  	(Параметр:  интервал       0 или 15-255 мс, флаг плавающего итервала ±50%).
		bool				setInterval_RX		(uint8_t				);										//	Объявляем  функцию установки    времени ожидания пакета повтора	    	(Параметр:  время ожидания 0 или 15-255 мс).
		bool				send				(uint8_t, uint8_t		);										//	Объявляем  функцию отправки     адреса и команды по ИК-каналу однократно(Параметр:  адрес, команда).
		bool				send				(uint16_t a				){ return send(a>>8, a&0xFF); }			//	Определяем функцию отправки     кода             по ИК-каналу однократно(Параметр:  код).
		bool				send32				(uint32_t				);										//	Объявляем  функцию отправки     кода             по ИК-каналу однократно(Параметр:  код). Функция используется для совместимости с библиотекой iarduino_IR.
		bool				autoSend			(uint8_t, uint8_t		);										//	Объявляем  функцию отправки     адреса и команды по ИК-каналу постоянно	(Параметр:  адрес, команда).
		bool				autoSend			(uint16_t a				){ return autoSend(a>>8, a&0xFF); }		//	Определяем функцию отправки     кода             по ИК-каналу постоянно	(Параметр:  код).
		bool				autoSend32			(uint32_t 				);										//	Объявляем  функцию отправки     кода             по ИК-каналу постоянно	(Параметр:  код). Функция используется для совместимости с библиотекой iarduino_IR.
		void				wait				(void					);										//	Объявляем  функцию ожидания     завершения однократной отправки			(Параметр:  отсутствует).
		bool				autoStop			(void					);										//	Объявляем  функцию остановки    постоянной отправки информации			(Параметр:  отсутствует).
		bool				check				(bool=false				);										//	Объявляем  функцию проверки     наличия принятых по ИК-каналу данных	(Параметр:  реагировать на пакеты повтора).
		bool				setProtocol			(uint8_t a, uint8_t b=0	){ return (setProtocol_TX(a,b) && setProtocol_RX(a,b)); }								//	Определяем функцию установки протокола приёма/передачи по ИК-каналу	(Параметр:  протокол, режим).
		uint8_t				getProtocol			(void					){ uint8_t a=getProtocol_TX(); return a==getProtocol_RX()?a:0; }						//	Определяем функцию получения протокола приёма/передачи по ИК-каналу	(Параметр:  отсутствует).
		bool				setInterval			(uint8_t a, bool b=false){ uint8_t c=a?(a>235?255:a+20):0; return (setInterval_TX(a,b) && setInterval_RX(c)); }	//	Определяем функцию установки интервала и ожидания пакетов повтора  	(Параметр:  интервал 0 или 24-255 мс, флаг плавающего итервала ±50%).
	/**	переменные доступные для пользователя **/																//
		uint8_t				length				=	0;															//	Переменная для чтения количества информационных бит в принятом пакете данных.
		uint32_t			code32				=	0;															//	Переменная для чтения информационных битов из принятого пакета данных.
		uint8_t				modeRC6				=	0;															//	Переменная для чтения режима используемого протоколом RC6.
		uint16_t			code				=	0;															//	Переменная для чтения принятых данных представленных двухбайтным числом, где старший байт это адрес ИК-устройства, а младший байт это команда ИК-устройства.
		uint8_t				address				=	0;															//	Переменная для чтения принятого байта адреса ИК-устройства.
		uint8_t				command				=	0;															//	Переменная для чтения принятого байта команды ИК-устройства.
		bool				key_press			=   0;															//  Флаг указывающий на то, что кнопка пульта нажимается а не удерживается.
		uint8_t				device				=	0;															//	Переменная указывает на наличие данных от модуля линейки «Дорожное движение»               (0-нет, MODUL_TLIGHT-светофор, MODUL_SIGN-знак, MODUL_CAR-машина).
		bool				track_F				=	0;															//	Флаг указывающий на то, что на перекрёстке управляемом светофором есть дорога прямо.
		bool				track_R				=	0;															//	Флаг указывающий на то, что на перекрёстке управляемом светофором есть дорога направо.
		bool				track_L				=	0;															//	Флаг указывающий на то, что на перекрёстке управляемом светофором есть дорога налево.
		uint8_t				forvard				=	0;															//	Флаг указывающий на то, что светофор линейки «Дорожное движение» разрешает движение прямо  (0-нельзя, 1-можно).
		uint8_t				right				=	0;															//	Флаг указывающий на то, что светофор линейки «Дорожное движение» разрешает движение вправо (0-нельзя, 1-можно).
		uint8_t				left				=	0;															//	Флаг указывающий на то, что светофор линейки «Дорожное движение» разрешает движение влево  (0-нельзя, 1-можно, 2-можно если нет помех).
		uint8_t				gate				=	0;															//	Флаг указывающий на состояние шлагбаума (0-закрыт, 1-открыт).
		uint8_t				sign[3]				=	{7,63,15};													//	Массив     хранящий обозначение знака линейки «Дорожное движение»                         (ГРУППА, НОМЕР, ПУНКТ).
		char				sign_str[8]			=	"7.63.15";													//	Строка     хранящая обозначение знака линейки «Дорожное движение»                         (""-нет, "1.1" ... "7.63.15" - знак ПДД от 1.1 до 7.63.15).
		uint16_t			sign_int			=	0;															//	Переменная хранящая обозначение знака линейки «Дорожное движение»                         (0-нет, 10100...76315 - знак ПДД от 1.1 до 7.63.15).
		uint8_t				sign_tab			=	0;															//	Переменная хранящая номер таблички под знаком, уточняющей или ограничивающей его действие (0-нет, SIGN_CAR_TRUCK-грузовые, SIGN_CAR_LIGHT-легковые, SIGN_DISTANCE_050-50м, SIGN_DISTANCE_100-100м, SIGN_DISTANCE_150-150м, SIGN_DISTANCE_200-200м, SIGN_DISTANCE_250-250м).
	private:																									//
	/**	Внутренние переменные **/																				//
		uint8_t				valAddrTemp			=	0;															//	Определяем переменную для хранения адреса модуля на шине I2C который был указан, но не был проверен.
		uint8_t				valAddr				=	0;															//	Определяем переменную для хранения адреса модуля на шине I2C.
		uint8_t				valVers				=	0;															//	Определяем переменную для хранения версии прошивки модуля.
		uint8_t				data[4];																			//	Объявляем  массив     для хранения получаемых/передаваемых данных.
		iarduino_I2C_BASE*	objI2C;																				//	Объявляем  указатель  на  объект полиморфного класса iarduino_I2C_BASE, но в конструкторе данного класса этому указателю будет присвоена ссылка на производный класс iarduino_I2C.
	/**	Внутренние функции **/																					//
		uint8_t 			_flip				(uint8_t									);					//	Объявляем  функцию переворачивающую биты байта									(Параметр:  байт биты которого требуется перевернуть).
		void				_coder32			(uint8_t, uint32_t*,uint8_t*,uint8_t*,bool	);					//	Объявляем  функцию преобразующую 32 битный код в адрес и команду, или наоборот	(Параметры: кодировка, код, адрес, команда, флаг направления преобразований).
		bool				_readBytes			(uint8_t, uint8_t							);					//	Объявляем  функцию чтения данных в  массив  data								(Параметры: номер первого регистра, количество байт).
		bool				_writeBytes			(uint8_t, uint8_t, uint8_t=0				);					//	Объявляем  функцию записи данных из массива data								(Параметры: номер первого регистра, количество байт, номер первого элемента массива data).
};																												//
																												//
#endif																											//